package controller

import (
	"archive/zip"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/laenix/vsentry/database"
	"github.com/laenix/vsentry/model"
	"github.com/spf13/viper"
)

var collectorTemplates = []model.ConnectorTemplate{
	{ID: "windows_event", Name: "Windows Event Collector", Type: "windows", Protocol: "api", DefaultPort: 0, Description: "Collect Windows Event Logs", Icon: "windows"},
	{ID: "linux_syslog", Name: "Linux Syslog Collector", Type: "linux", Protocol: "syslog", DefaultPort: 514, Description: "Collect Linux syslog", Icon: "linux"},
	{ID: "macos_log", Name: "macOS Unified Logging", Type: "macos", Protocol: "api", DefaultPort: 0, Description: "Collect macOS unified logging", Icon: "apple"},
}

// ListCollectorConfigs 获取采集器配置列表
func ListCollectorConfigs(ctx *gin.Context) {
	db := database.GetDB()
	var configs []model.CollectorConfig
	db.Find(&configs)
	ctx.JSON(200, gin.H{"code": 200, "data": configs})
}

// GetCollectorTemplates 获取采集器模板列表
func GetCollectorTemplates(ctx *gin.Context) {
	// Return our predefined templates
	templates := []map[string]interface{}{
		{
			"id":          "windows_event",
			"name":        "Windows Event Collector",
			"type":        "windows",
			"description": "Collect Windows Event Logs (Application, System, Security, etc.)",
			"icon":        "windows",
			"channels":    []string{"System", "Application", "Security", "PowerShell", "DNS", "Microsoft-Windows-PowerShell/Operational"},
		},
		{
			"id":          "linux_syslog",
			"name":        "Linux Syslog Collector",
			"type":        "linux",
			"description": "Collect Linux syslog via rsyslog/syslog-ng",
			"icon":        "linux",
			"channels":    []string{"auth", "authpriv", "cron", "daemon", "kern", "mail", "syslog"},
		},
		{
			"id":          "macos_unified",
			"name":        "macOS Unified Logging",
			"type":        "macos",
			"description": "Collect macOS unified logging",
			"icon":        "apple",
			"channels":    []string{"system", "network", "wifi", "install"},
		},
	}
	ctx.JSON(200, gin.H{"code": 200, "data": templates})
}

// AddCollectorConfig 添加采集器配置
func AddCollectorConfig(ctx *gin.Context) {
	var req model.CollectorConfig
	if err := ctx.ShouldBindJSON(&req); err != nil {
		ctx.JSON(400, gin.H{"msg": "参数错误"})
		return
	}

	// Get external URL from config
	externalURL := viper.GetString("server.external_url")
	if externalURL == "" {
		externalURL = "http://localhost:8088"
	}

	// Set default values
	if req.StreamFields == "" {
		req.StreamFields = "channel,source,host"
	}
	req.BuildStatus = "pending"

	database.GetDB().Create(&req)
	ctx.JSON(200, gin.H{"code": 200, "msg": "Created successfully", "data": req})
}

// UpdateCollectorConfig 更新采集器配置
func UpdateCollectorConfig(ctx *gin.Context) {
	var req model.CollectorConfig
	if err := ctx.ShouldBindJSON(&req); err != nil {
		ctx.JSON(400, gin.H{"msg": "参数错误"})
		return
	}

	if req.ID == 0 {
		ctx.JSON(400, gin.H{"msg": "ID is required"})
		return
	}

	var existing model.CollectorConfig
	if err := database.GetDB().First(&existing, req.ID).Error; err != nil {
		ctx.JSON(404, gin.H{"msg": "Not found"})
		return
	}

	database.GetDB().Model(&existing).Updates(req)
	ctx.JSON(200, gin.H{"code": 200, "msg": "Updated successfully"})
}

// DeleteCollectorConfig 删除采集器配置
func DeleteCollectorConfig(ctx *gin.Context) {
	id := ctx.Query("id")
	database.GetDB().Delete(&model.CollectorConfig{}, id)
	ctx.JSON(200, gin.H{"code": 200, "msg": "Deleted successfully"})
}

func generateCollectorConfig(config model.CollectorConfig, endpoint string) string {
	// Parse sources from JSON
	var sourcesJson string
	if config.Sources != "" {
		sourcesJson = config.Sources
	} else if config.Channels != "" && config.Type == "windows" {
		// Convert comma-separated channels to sources JSON for Windows
		channels := strings.Split(config.Channels, ",")
		var sources []map[string]interface{}
		for _, ch := range channels {
			ch = strings.TrimSpace(ch)
			if ch != "" {
				sources = append(sources, map[string]interface{}{
					"type":    ch,
					"path":    ch,
					"format":  "windows_event",
					"enabled": true,
				})
			}
		}
		data, _ := json.Marshal(sources)
		sourcesJson = string(data)
	}

	// Generate config.yaml based on type
	if config.Type == "linux" && sourcesJson != "" {
		// Linux uses sources
		return fmt.Sprintf(`# VSentry Collector Configuration
# Generated by VSentry

# Collector Name
name: %s

# Collector Type (windows/linux/macos)
type: %s

# Collection interval in seconds
interval: %d

# Data Sources (JSON)
sources: %s

# Ingest Settings (auto-configured by VSentry)
ingest:
  endpoint: %s
  token: %s
  stream_fields: %s
`, config.Name, config.Type, config.Interval, sourcesJson, endpoint, config.Token, config.StreamFields)
	} else {
		// Windows uses channels (legacy)
		channels := strings.Split(config.Channels, ",")
		var channelsYaml strings.Builder
		for _, ch := range channels {
			ch = strings.TrimSpace(ch)
			if ch != "" {
				channelsYaml.WriteString("  - " + ch + "\n")
			}
		}

		return fmt.Sprintf(`# VSentry Collector Configuration
# Generated by VSentry

# Collector Name
name: %s

# Collector Type (windows/linux/macos)
type: %s

# Channels to collect (one per line)
channels:
%s
# Ingest Settings (auto-configured by VSentry)
ingest:
  endpoint: %s
  token: %s
  stream_fields: %s

# Collection interval in seconds
interval: %d
`, config.Name, config.Type, channelsYaml.String(), endpoint, config.Token, config.StreamFields, config.Interval)
	}
}

func createCollectorZip(config model.CollectorConfig, configContent string) (*bytes.Buffer, error) {
	buf := new(bytes.Buffer)
	w := zip.NewWriter(buf)

	// 1. Add config.yaml with the embedded Ingest config
	f, err := w.Create("config.yaml")
	if err != nil {
		return nil, err
	}
	f.Write([]byte(configContent))

	// 2. Add README.md
	readme := fmt.Sprintf(`# %s - VSentry Collector

## Quick Start

1. Extract this archive on your Windows machine
2. Edit config.yaml to select the channels you want to collect
3. Run: powershell -ExecutionPolicy Bypass -File collector.ps1

## Requirements

- Windows 10/11 or Windows Server 2016+
- PowerShell 5.1 or later
- Network access to your VSentry server

## Configuration

The config.yaml is pre-configured with your VSentry server settings:
- Endpoint: Already configured
- Token: Already configured
- Channels: Adjust as needed (System, Application, Security, etc.)

## Supported Channels

Windows Event Log Channels:
- System - System events and errors
- Application - Application logs
- Security - Security events (requires admin)
- PowerShell - PowerShell execution logs
- DNS - DNS server queries
- Microsoft-Windows-PowerShell/Operational - Detailed PowerShell logs

## Testing

To test if the collector works:
1. Start VSentry
2. Run the collector: powershell -ExecutionPolicy Bypass -File collector.ps1
3. Check VSentry Logs page for incoming data

## Troubleshooting

- If no logs appear, check Windows Event Log service is running
- For Security channel logs, run PowerShell as Administrator
- Check network connectivity to VSentry server

---
Generated by VSentry Collector Builder
`, config.Name)

	f2, _ := w.Create("README.md")
	f2.Write([]byte(readme))

	// 3. Add the PowerShell collector script
	ps1Content := getCollectorScript(config, configContent)
	f3, err := w.Create("collector.ps1")
	if err != nil {
		return nil, err
	}
	f3.Write([]byte(ps1Content))

	// 4. Add a simple batch runner
	runBat := `@echo off
echo VSentry Collector - %s
echo ========================================
echo.
echo Starting collector...
echo Press Ctrl+C to stop
echo.
powershell -ExecutionPolicy Bypass -File collector.ps1
pause
`
	batFile, _ := w.Create("run_collector.bat")
	batFile.Write([]byte(fmt.Sprintf(runBat, config.Name)))

	// 5. Add Go binary based on type
	var binaryName string
	if config.Type == "windows" {
		binaryName = "redAgent.exe"
	} else {
		binaryName = "redAgent"
	}

	// Try to read binary from /app/collector/ (Docker build path)
	binaryPath := "/app/collector/" + binaryName
	binaryData, err := os.ReadFile(binaryPath)

	if err != nil {
		// Try alternate paths
		altPaths := []string{
			"/app/collector/redAgent",
			"/redAgent-source/redAgent.exe",
			"/redAgent-source/redAgent",
		}
		for _, p := range altPaths {
			binaryData, err = os.ReadFile(p)
			if err == nil {
				break
			}
		}
	}

	if err == nil {
		binaryFile, err := w.Create(binaryName)
		if err == nil {
			binaryFile.Write(binaryData)
			log.Printf("Added binary: %s (%d bytes)", binaryName, len(binaryData))
		}

		// Add platform-specific run script
		if config.Type == "linux" {
			runScript := fmt.Sprintf(`#!/bin/bash
echo "VSentry Collector - %s"
echo "========================"
echo ""
echo "Starting collector..."
echo ""
chmod +x ./redAgent
./redAgent -config config.yaml
`, config.Name)
			w.Create("run_collector.sh")
			_, _ = w.Create("run_collector.sh")
			log.Printf("Added Linux run script for %s", config.Name)
			_ = runScript // suppress unused warning in release build
		}
	}

	w.Close()
	return buf, nil
}

// getCollectorScript generates the PowerShell collector script with embedded config
func getCollectorScript(config model.CollectorConfig, configContent string) string {
	// Parse channels
	channels := strings.Split(config.Channels, ",")
	var channelList []string
	for _, ch := range channels {
		ch = strings.TrimSpace(ch)
		if ch != "" {
			channelList = append(channelList, ch)
		}
	}
	if len(channelList) == 0 {
		channelList = []string{"System", "Application"}
	}

	// Get Ingest info from config
	// Parse from the generated config content
	var endpoint, token, streamFields string
	lines := strings.Split(configContent, "\n")
	for _, line := range lines {
		if strings.Contains(line, "endpoint:") {
			endpoint = strings.TrimSpace(strings.Split(line, ":")[1])
		}
		if strings.Contains(line, "token:") {
			token = strings.TrimSpace(strings.Split(line, ":")[1])
		}
		if strings.Contains(line, "stream_fields:") {
			streamFields = strings.TrimSpace(strings.Split(line, ":")[1])
		}
	}

	// Generate channel array for PowerShell
	channelsJson, _ := json.Marshal(channelList)

	return fmt.Sprintf(`# VSentry Collector for Windows
# Version: 1.0
# Auto-generated by VSentry Collector Builder

# === CONFIGURATION (Embedded) ===
$Config = @{
    Name = "%s"
    Type = "%s"
    Channels = %s
    Ingest = @{
        Endpoint = "%s"
        Token = "%s"
        StreamFields = "%s"
    }
    Interval = 5
}

Write-Host "VSentry Collector v1.0"
Write-Host "Channels: $($Config.Channels -join ', ')"
Write-Host "Endpoint: $($Config.Ingest.Endpoint)"

function Send-ToVSentry {
    param([array]$Logs)
    if ($Logs.Count -eq 0) { return }
    try {
        $json = $Logs | ConvertTo-Json -Compress -Depth 3
        $headers = @{
            "Authorization" = "Bearer $($Config.Ingest.Token)"
            "Content-Type" = "application/json"
        }
        Invoke-RestMethod -Uri $Config.Ingest.Endpoint -Method Post -Headers $headers -Body $json -TimeoutSec 30 -ErrorAction Stop | Out-Null
        Write-Host "[OK] Sent $($Logs.Count) logs"
    } catch {
        Write-Host "[ERROR] $($_.Exception.Message)"
    }
}

function Collect-ChannelLogs {
    param([string]$Channel)
    try {
        $events = Get-WinEvent -FilterHashtable @{LogName=$Channel; StartTime=(Get-Date).AddMinutes(-$Config.Interval)} -MaxEvents 30 -ErrorAction SilentlyContinue
        if (-not $events) { return @() }
        
        $logs = @()
        $hostname = $env:COMPUTERNAME
        $levelMap = @{1='critical';2='error';3='warning';4='information'}
        
        foreach ($e in $events) {
            $msg = if ($e.Message) { $e.Message.Substring(0, [Math]::Min(3000, $e.Message.Length)) } else { "" }
            $level = if ($levelMap[$e.Level]) { $levelMap[$e.Level] } else { "info" }
            
            $logs += @{
                _time = $e.TimeCreated.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
                host = $hostname
                source = $Channel
                channel = $Channel
                message = $msg
                level = $level
                event_id = $e.Id
                provider = $e.ProviderName
            }
        }
        return $logs
    } catch {
        return @()
    }
}

# Main loop
Write-Host "Starting collection... (Ctrl+C to stop)"
while ($true) {
    $allLogs = @()
    foreach ($ch in $Config.Channels) {
        $allLogs += Collect-ChannelLogs -Channel $ch
    }
    if ($allLogs.Count -gt 0) {
        Send-ToVSentry -Logs $allLogs
    }
    Start-Sleep -Seconds $Config.Interval
}
`, config.Name, config.Type, string(channelsJson), endpoint, token, streamFields)
}

// GetAvailableChannels 获取指定类型可用的采集通道
func GetAvailableChannels(ctx *gin.Context) {
	collectorType := ctx.Query("type")

	channels := map[string][]map[string]string{
		"windows": {
			{"type": "System", "path": "System", "label": "System"},
			{"type": "Application", "path": "Application", "label": "Application"},
			{"type": "Security", "path": "Security", "label": "Security (requires admin)"},
			{"type": "PowerShell", "path": "Microsoft-Windows-PowerShell/Operational", "label": "PowerShell"},
			{"type": "DNS", "path": "DNS", "label": "DNS"},
			{"type": "Sysmon", "path": "Microsoft-Windows-Sysmon/Operational", "label": "Sysmon"},
			{"type": "Defender", "path": "Microsoft-Windows-Windows Defender/Operational", "label": "Windows Defender"},
		},
		"linux": {
			{"type": "syslog", "path": "/var/log/syslog", "label": "Syslog"},
			{"type": "auth", "path": "/var/log/auth.log", "label": "Auth Log"},
			{"type": "secure", "path": "/var/log/secure", "label": "Secure (SSH)"},
			{"type": "nginx_access", "path": "/var/log/nginx/access.log", "label": "Nginx Access"},
			{"type": "nginx_error", "path": "/var/log/nginx/error.log", "label": "Nginx Error"},
			{"type": "apache_access", "path": "/var/log/apache2/access.log", "label": "Apache Access"},
			{"type": "kern", "path": "/var/log/kern.log", "label": "Kernel Log"},
			{"type": "messages", "path": "/var/log/messages", "label": "Messages"},
		},
		"macos": {
			{"type": "system", "path": "system", "label": "System Log"},
			{"type": "install", "path": "system.install", "label": "Install Log"},
			{"type": "network", "path": "system.net", "label": "Network Log"},
			{"type": "wifi", "path": "system.wifi", "label": "WiFi Log"},
		},
	}

	if ch, ok := channels[collectorType]; ok {
		// Return as array of {type, path, label} objects
		formatted := make([]map[string]string, len(ch))
		for i, item := range ch {
			if len(item) >= 3 {
				formatted[i] = map[string]string{
					"type":  item["type"],
					"path":  item["path"],
					"label": item["label"],
				}
			} else {
				formatted[i] = item
			}
		}
		ctx.JSON(200, gin.H{"code": 200, "data": formatted})
	} else {
		ctx.JSON(200, gin.H{"code": 200, "data": []string{}})
	}
}

// BuildCollector 动态编译跨平台采集器
func BuildCollector(ctx *gin.Context) {
	id := ctx.Query("id")
	if id == "" {
		ctx.JSON(400, gin.H{"msg": "ID is required"})
		return
	}

	db := database.GetDB()
	var config model.CollectorConfig
	if err := db.First(&config, id).Error; err != nil {
		ctx.JSON(404, gin.H{"msg": "Config not found"})
		return
	}

	// 1. 核心修复：动态关联查询真实的 Ingest 参数
	var endpoint, token, streamFields string

	if config.IngestID > 0 {
		// 如果前端关联了系统的 Ingest 实例，则去数据库抓取实时凭证
		var ingest model.Ingest
		var auth model.IngestAuth

		if err := db.First(&ingest, config.IngestID).Error; err != nil {
			ctx.JSON(400, gin.H{"msg": "关联的接入点 (Ingest) 不存在"})
			return
		}
		if err := db.Where("ingest_id = ?", ingest.ID).First(&auth).Error; err != nil {
			ctx.JSON(400, gin.H{"msg": "接入点凭证 (Token) 异常"})
			return
		}

		endpoint = ingest.Endpoint
		token = auth.SecretKey // 这才是真实的 JWT / 认证 Token
		streamFields = ingest.StreamFields
	} else {
		// 容错：处理用户手动覆盖输入端点和 Token 的情况
		endpoint = config.IngestEndpoint
		if endpoint == "" {
			extURL := viper.GetString("server.external_url")
			if extURL == "" {
				extURL = "http://localhost:8088"
			}
			endpoint = extURL + "/api/ingest/collect"
		}
		token = config.Token
		streamFields = config.StreamFields
	}

	// 更新状态为构建中
	db.Model(&config).Update("build_status", "building")

	// 2. 生成要嵌入二进制的 JSON 配置 (传入我们刚刚查到的真实数据)
	embeddedConfigJSON := generateEmbeddedJSON(config, endpoint, token, streamFields)

	// 3. 执行动态编译 (复用之前的 compileAgentDynamic)
	binaryPath, err := compileAgentDynamic(config.Type, embeddedConfigJSON)
	if err != nil {
		db.Model(&config).Updates(map[string]interface{}{
			"build_status": "failed",
			"build_output": err.Error(),
		})
		ctx.JSON(500, gin.H{"msg": "Compilation failed: " + err.Error()})
		return
	}
	defer os.Remove(binaryPath) // 传输完毕后清理文件

	db.Model(&config).Updates(map[string]interface{}{
		"build_status": "completed",
		"build_output": "Compilation successful",
	})

	// 4. 将编译好的专属二进制文件发给浏览器下载
	fileName := fmt.Sprintf("vsentry-agent-%d", config.ID)
	if config.Type == "windows" {
		fileName += ".exe"
	}

	ctx.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", fileName))
	ctx.Header("Content-Type", "application/octet-stream")
	ctx.File(binaryPath)
}

// compileAgentDynamic 核心编译逻辑：利用临时隔离目录保证并发构建的安全
func compileAgentDynamic(targetOS model.CollectorType, configJSON []byte) (string, error) {
	// Monorepo 架构下，Agent 源码默认在后端运行目录的 ./cmd/collectors 下
	// 如果你将 VSentry 部署在 Docker 中，请确保这个路径与 Dockerfile 中的源码路径一致
	sourceDir := "./cmd/collectors"
	if _, err := os.Stat(sourceDir); os.IsNotExist(err) {
		return "", fmt.Errorf("agent source directory not found at %s", sourceDir)
	}

	// 1. 创建隔离的临时目录，防止并发构建时配置互相覆盖
	tempBuildDir, err := os.MkdirTemp("", "vsentry-build-*")
	if err != nil {
		return "", fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(tempBuildDir) // 无论成功失败，结束时清理临时源码目录

	// 2. 将纯净的 Agent 源码拷贝到临时目录
	if err := copyDir(sourceDir, tempBuildDir); err != nil {
		return "", fmt.Errorf("failed to copy agent source: %w", err)
	}

	// 3. 将动态配置写入 embed 预期的路径 (精确覆盖空白的 config.json)
	configFilePath := filepath.Join(tempBuildDir, "config", "config.json")
	if err := os.WriteFile(configFilePath, configJSON, 0644); err != nil {
		return "", fmt.Errorf("failed to write embedded config: %w", err)
	}

	// 4. 准备交叉编译环境
	goos := "linux"
	switch targetOS {
	case "windows":
		goos = "windows"
	case "macos":
		goos = "darwin"
	default:
		goos = "linux"
	}

	outputFile := filepath.Join(tempBuildDir, "vsentry-agent")
	if goos == "windows" {
		outputFile += ".exe"
	}

	// 5. 调用 Go 编译器
	// -trimpath: 隐藏服务器路径信息，增加逆向难度
	// -s -w: 剥离符号表和调试信息，大幅减小二进制体积
	cmd := exec.Command("go", "build", "-trimpath", "-ldflags", "-s -w", "-o", outputFile, ".")
	cmd.Dir = tempBuildDir

	// 继承宿主环境变量，但强制覆盖交叉编译核心参数
	cmd.Env = append(os.Environ(),
		"GOOS="+goos,
		"GOARCH=amd64",  // 默认构建 amd64，如果未来需要支持 ARM，可将此变为参数
		"CGO_ENABLED=0", // 强制关闭 CGO，确保零依赖
	)

	// 捕获编译时的标准输出和错误
	if output, err := cmd.CombinedOutput(); err != nil {
		log.Printf("Compile error output: %s", string(output))
		return "", fmt.Errorf("go build failed: %s", string(output))
	}

	// 6. 将生成的二进制文件移出临时目录，存放到系统的 /tmp 下供后续下载
	finalPath := filepath.Join(os.TempDir(), fmt.Sprintf("agent_%d_%s", time.Now().UnixNano(), filepath.Base(outputFile)))
	if err := copyFile(outputFile, finalPath); err != nil {
		return "", fmt.Errorf("failed to move compiled binary: %w", err)
	}

	return finalPath, nil
}

// generateEmbeddedJSON 接收从数据库提取的真实配置参数
func generateEmbeddedJSON(config model.CollectorConfig, endpoint, token, streamFields string) []byte {
	var sources []map[string]interface{}

	// 处理 Linux/macOS 的原生 Sources JSON
	if config.Sources != "" {
		json.Unmarshal([]byte(config.Sources), &sources)
	} else if config.Channels != "" && config.Type == "windows" {
		// 兼容 Windows 旧的逗号分隔 Channel 模式
		channels := strings.Split(config.Channels, ",")
		for _, ch := range channels {
			ch = strings.TrimSpace(ch)
			if ch != "" {
				sources = append(sources, map[string]interface{}{
					"type": ch, "path": ch, "format": "windows_event", "enabled": true,
				})
			}
		}
	}

	// 构造注入 Agent 的全局配置结构
	payload := map[string]interface{}{
		"name":          config.Name,
		"type":          config.Type,
		"interval":      config.Interval,
		"sources":       sources,
		"endpoint":      endpoint,
		"token":         token,
		"stream_fields": streamFields,
	}

	data, _ := json.MarshalIndent(payload, "", "  ")
	return data
}

// ================= 工具函数区 =================

// copyDir 递归拷贝目录 (纯 Go 实现，跨平台安全)
func copyDir(src string, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}
	if err := os.MkdirAll(dst, srcInfo.Mode()); err != nil {
		return err
	}

	entries, err := os.ReadDir(src)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())

		if entry.IsDir() {
			if err := copyDir(srcPath, dstPath); err != nil {
				return err
			}
		} else {
			if err := copyFile(srcPath, dstPath); err != nil {
				return err
			}
		}
	}
	return nil
}

// copyFile 拷贝单个文件
func copyFile(src, dst string) error {
	in, err := os.Open(src)
	if err != nil {
		return err
	}
	defer in.Close()

	out, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, in)
	if err != nil {
		return err
	}
	return out.Sync()
}
